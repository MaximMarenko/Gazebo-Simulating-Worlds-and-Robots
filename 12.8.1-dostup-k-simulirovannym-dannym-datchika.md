# 12.8.1 Доступ к симулированным данным датчика

Настоящий робот Kobuki имеет три датчика обрыва \(левый, правый и центральный\) и три датчика удара \(левый, правый и центральный\), а модель Kobuki Gazebo включает в себя плагины для каждого из этих датчиков. Это означает, что имитация Kobuki может обнаружить, когда он собирается съехать с края или когда он столкнулся с чем-то вроде шлакоблока. Моделированные данные датчиков публикуются по двум разделам ROS: _/mobile\_base/events/cliff_ и _/mobile\_base/events/bumper_.

Вы можете убедиться в том, что симулированные датчики обрывов работают, отслеживая с помощью команды раздел _/mobile\_base/events/cliff_:

```text
$ rostopic echo /mobile_base/events/cliff
```

Изначально вы увидите следующий вывод:

> WARNING: no messages received and simulated time is active. Is /clock being published?

Это предупреждение ожидаемо, так как мы проводим симуляцию, робот ненастоящий, и датчики обрыва публикуют сообщение только тогда, когда хотя бы один из них обнаруживает обрыв.

Теперь повторите эксперимент, описанный в предыдущем разделе, и установите направление робота к краю стола, не отрывайте глаз от окна терминала, наблюдая за сообщениями об обрыве. Может помочь замедлить скорость робота, поэтому на этот раз измените линейную скорость до 0,1 метра в секунду:

```text
$ rostopic pub -r 10 /mobile_base/commands/velocity geometry_msgs/Twist
'{linear: {x: 0.1}}'
```

По мере прохождения робота через край стола, вы должны увидеть следующие три сообщения в теме /mobile\_base/events/cliff:

```text
sensor: 1 state:
1 bottom: 42647
--- sensor: 0
state: 1
bottom: 50660
--- sensor: 2
state: 1
bottom: 42647
---
```

Эти сообщения указывают на то, что все три датчика "обрыва" \(обозначенные в поле датчика выше 0, 1 и 2\) вошли в состояние 1, что означает "обрыв обнаружен". Значения, отображаемые в нижнем поле, представляют собой расстояние до пола, хотя из документации Kobuki неясно, что это за устройства. Кроме того, имейте в виду, что ИК-датчики, используемые для обнаружения обрывов, имеют радиус действия всего 2-15 см, а столешницы находятся намного выше от пола чем этот радиус.

Чтобы увидеть описание сообщений об обрыве Kobuki, запустите команду:

```text
$ rosmsg show -r kobuki_msgs/CliffEvent
```

Опция -r означает "raw" и включает комментарии, написанные в файле описания сообщения. Ключевая часть вывода:

```text
# cliff sensor
uint8 LEFT = 0
uint8 CENTER = 1
uint8 RIGHT = 2
# cliff sensor state
uint8 FLOOR = 0
uint8 CLIFF = 1
uint8 sensor
uint8 state
# distance to floor when cliff was detected
uint16 bottom
```

Описание сообщения показывает, что каждое сообщение имеет три поля, датчик, состояние и дно, и что поле датчика может иметь значения 0, 1 и 2 для обозначения левого, центрального и правого ИК-датчиков, в то время как поле состояния принимает значение 0, если обнаружен пол, или 1, если обнаружен обрыв.

Чтобы протестировать имитированные датчики ухаба, сначала завершите команду публикации скорости, если она все еще выполняется. Затем нажмите на меню **Edit** \(Редактировать\) в графическом интерфейсе Gazebo и выберите **Reset Model Poses** \(Сбросить позиции модели\). Вы заметите, что теперь робот готов столкнуться с одним из шлакоблоков.

![](.gitbook/assets/image%20%2814%29.png)

Для контроля сообщений по разделу датчиков удара выполните команду:

```text
$ rostopic echo /mobile_base/events/bumper
```

Заставьте робота двигаться к блоку:

```text
$ rostopic pub -r 10 /mobile_base/commands/velocity geometry_msgs/Twist
'{linear: {x: 0.2}}'
```

Затем вернитесь к другому окну терминала и следите за сообщениями на датчике удара во время просмотра робота в Gazebo. В момент удара робота по блоку, вы должны увидеть серию сообщений в разделе датчика удара, которые выглядят так:

```text
bumper: 1
state: 1
---
bumper: 1
state: 0
---
bumper: 1
state: 1 -
--
```

Как и датчики обрыва, датчики удара пронумерованы 0, 1 и 2 для левой, центральной и правой стороны. Таким образом, сообщение выше показывает, что центральный датчик ударил по объекту, отскочил достаточно, чтобы освободить датчик, а затем ударил снова, так как робот продолжает двигаться вперед. Чтобы увидеть описания сообщений _BumperEvent_, выполните команду:

```text
$ rosmsg show -r kobuki_msgs/BumperEvent
```

```text
# bumper uint8
LEFT = 0
uint8 CENTER =
1 uint8 RIGHT
= 2
# state uint8
RELEASED = 0
uint8 PRESSED =
1
uint8 bumper
uint8 state
```

что показывает нам, что есть три датчика, которые могут иметь значение состояния либо 0 \(освобождено\), либо 1 \(нажато\).

Когда публикация данных о скорости все еще работает, используйте мышь, чтобы переместить робота обратно от блока, но на этот раз прицельтесь так, чтобы он ударил по блоку с левой или с правой стороны робота. На этот раз вы должны увидеть сообщение о том, что датчик 0 \(слева\) или 2 \(справа\) был нажат.

Обратите внимание, что при наезде на объект робот не останавливается\*, так же как и датчики обрыва не останавливают робота автоматически от падения со стола. В следующем разделе мы посмотрим, как более безопасно управлять роботом.

\(\* Когда симулированный Kobuki бежит головой к объекту, кажется, что он останавливается. Однако, это происходит просто потому, что движение вперед затрудняется объектом, а не потому, что приводные двигатели остановились. Как мы видели выше, робот фактически отскочил от шлакоблока и продолжал толкаться против него\).

